# -*- coding: utf-8 -*-
"""生物機器學習Assignment_1 (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ifdG3El2pXp0nyq65v0xxMwAt3eQXNAw

# HW1 Pipeline（TARGET_RESIDUES = Cysteine）

**說明**  
本 Notebook 依作業規格完成資料前處理：
- 讀取 `train_demo.txt`（或換成你的大檔），格式：`acc\tpos\tptm\tseq`
- 以 **2n+1 視窗** 擷取樣本，**中心必為 C**；若 **N/C 端不足** → **丟棄**
- **負樣本去重疊**：凡與任何**正樣本視窗重疊**（含負位點落入正視窗範圍），**剔除負樣本、保留正樣本**
- 匯出 **FASTA**（供 CD-HIT 同源性去除）與 **CSV**（便於檢視）
- 全程中文註解，方便閱讀

> 你只要在「參數區」改 `INPUT_PATH` 與 `WINDOW_N`，即可套用到完整資料集。
"""

from pathlib import Path

def ask_int(prompt: str, min_value: int = 1) -> int:
    while True:
        s = input(prompt).strip()
        try:
            v = int(s)
            if v >= min_value:
                return v
        except ValueError:
            pass
        print(f"❗輸入無效，請輸入 ≥ {min_value} 的整數。")

# 互動輸入 N（視窗半徑）
WINDOW_N = ask_int("請輸入 N（視窗半徑，正整數）：", 1)

# 依 N 建立輸出資料夾，例如 /content/result_N=10
OUTPUT_DIR = Path(f"/content/result_N={WINDOW_N}")
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

print("本次視窗長度將為：", 2*WINDOW_N + 1)
print("輸出資料夾：", OUTPUT_DIR)
       # 匯出檔名前綴（不含副檔名）

# ===== 函式區（中文註解） =====
import re
from dataclasses import dataclass
from typing import List
import pandas as pd

@dataclass
class Record:
    """單筆原始資料（對應 TSV 一行）"""
    acc: str            # UniProt accession 或自定ID
    pos: int            # 正樣本位點（1-based index）
    ptm: str            # 註記之 PTM 類型（本作業邏輯不依賴此欄，可保留）
    seq: str            # 蛋白質完整胺基酸序列（僅 A-Z）

@dataclass
class WindowSeq:
    """擷取後的視窗序列與其中繼資訊"""
    acc: str
    center_pos: int     # 視窗中心位點（原蛋白 1-based）
    label: int          # 1=positive, 0=negative
    window: str         # 長度 2n+1，中心必為 TARGET_RESIDUE
    left: int           # 視窗在原序列的起始（1-based, inclusive）
    right: int          # 視窗在原序列的結束（1-based, inclusive）

def sanitize_sequence(seq: str) -> str:
    """清理序列字串：只保留英文字母（排除空白、點號、數字等），並轉大寫。"""
    seq = re.sub(r'[^A-Za-z]', '', seq or '')
    return seq.upper()

def parse_tsv(path: Path) -> List[Record]:
    """讀取 TSV（四欄：acc, pos, ptm, seq），回傳 Record 物件列表。"""
    df = pd.read_csv(path, sep="\t", header=None, names=["acc", "pos", "ptm", "seq"], dtype=str)
    recs: List[Record] = []
    for _, row in df.iterrows():
        acc = (row["acc"] or "").strip()
        pos = int(row["pos"])
        ptm = (row["ptm"] or "").strip()
        seq = sanitize_sequence(row["seq"] or "")
        if not seq:
            continue
        recs.append(Record(acc=acc, pos=pos, ptm=ptm, seq=seq))
    return recs

def extract_pos_windows(rec: Record, n: int, target: str) -> List[WindowSeq]:
    """擷取正樣本（中心必為 target；視窗不足丟棄）。"""
    pos = rec.pos  # 1-based
    seq = rec.seq
    L = len(seq)
    left = pos - n
    right = pos + n
    if left < 1 or right > L:  # 視窗不足 → 丟棄
        return []
    if seq[pos - 1] != target:  # 中心不是目標殘基 → 丟棄
        return []
    win = seq[left - 1:right]
    return [WindowSeq(acc=rec.acc, center_pos=pos, label=1, window=win, left=left, right=right)]

def all_target_positions(seq: str, target: str) -> List[int]:
    """回傳序列中所有 target 的 1-based 位置。"""
    return [i + 1 for i, aa in enumerate(seq) if aa == target]

def intervals_overlap(a_left: int, a_right: int, b_left: int, b_right: int) -> bool:
    """檢查兩區間是否重疊（含端點相接視為重疊）。"""
    return not (a_right < b_left or b_right < a_left)

def extract_neg_windows(rec: Record, n: int, target: str, pos_windows: List[WindowSeq]) -> List[WindowSeq]:
    """擷取負樣本：
    - 以序列中所有 target 位置為候選（排除已標記為正的中心）
    - 視窗不足丟棄
    - 與任一正樣本視窗重疊 → 丟棄（包含負位點落在正視窗內）
    """
    seq = rec.seq
    L = len(seq)
    pos_centers = {w.center_pos for w in pos_windows}
    pos_intervals = [(w.left, w.right) for w in pos_windows]
    neg_list: List[WindowSeq] = []
    for p in all_target_positions(seq, target):
        if p in pos_centers:
            continue
        left = p - n
        right = p + n
        if left < 1 or right > L:
            continue
        if any(intervals_overlap(left, right, pl, pr) for (pl, pr) in pos_intervals):
            continue
        win = seq[left - 1:right]
        neg_list.append(WindowSeq(acc=rec.acc, center_pos=p, label=0, window=win, left=left, right=right))
    return neg_list

def windows_to_dataframe(wins: List[WindowSeq]) -> pd.DataFrame:
    """轉為 DataFrame，方便檢視或輸出 CSV。"""
    return pd.DataFrame([{
        "acc": w.acc,
        "center_pos": w.center_pos,
        "label": w.label,
        "left": w.left,
        "right": w.right,
        "window": w.window
    } for w in wins])

def write_fasta(wins: List[WindowSeq], out_path: Path):
    """輸出 FASTA（供 CD-HIT 使用）。標頭含 acc|pos|label|range。"""
    lines = []
    for w in wins:
        header = f">{w.acc}|pos={w.center_pos}|label={w.label}|range={w.left}-{w.right}"
        lines.append(header)
        lines.append(w.window)
    out_path.write_text("\n".join(lines))

# ===== 主流程 =====
INPUT_PATH = Path("/content/train.txt")
TARGET_RESIDUE = "C"

records = parse_tsv(INPUT_PATH)
all_pos, all_neg = [], []

for rec in records:
    pos_wins = extract_pos_windows(rec, n=WINDOW_N, target=TARGET_RESIDUE)
    neg_wins = extract_neg_windows(rec, n=WINDOW_N, target=TARGET_RESIDUE, pos_windows=pos_wins)
    all_pos.extend(pos_wins)
    all_neg.extend(neg_wins)

df_pos = windows_to_dataframe(all_pos)
df_neg = windows_to_dataframe(all_neg)

# ===== 匯出到 /content/result_N=<N>，檔名固定為 pos/neg =====
pos_fa  = OUTPUT_DIR / "pos.fasta"
neg_fa  = OUTPUT_DIR / "neg.fasta"
pos_csv = OUTPUT_DIR / "pos.csv"
neg_csv = OUTPUT_DIR / "neg.csv"

write_fasta(all_pos, pos_fa)
write_fasta(all_neg, neg_fa)
df_pos.to_csv(pos_csv, index=False)
df_neg.to_csv(neg_csv, index=False)

summary = {
    "N": WINDOW_N,
    "window_len": 2*WINDOW_N + 1,
    "out_dir": str(OUTPUT_DIR),
    "pos_count": len(all_pos),
    "neg_count": len(all_neg),
    "pos_fasta": str(pos_fa),
    "neg_fasta": str(neg_fa),
    "pos_csv": str(pos_csv),
    "neg_csv": str(neg_csv),
}
summary

# ===== 觀察輸出（前 5 筆） =====
import pandas as pd
pd.options.display.max_colwidth = 120
print("Positive windows:")
display(pd.read_csv(pos_csv).head())
print("Negative windows:")
display(pd.read_csv(neg_csv).head())

"""安裝CD-HIT"""

# 更新系統的軟件包列表
!apt-get update

# 安裝 CD-HIT 軟件，用於蛋白質或核酸序列的聚類
!apt-get install cd-hit

# 檢查 cd-hit 的安裝路徑
!which cd-hit

# 依前面設定好的 WINDOW_N / OUTPUT_DIR（= /content/result_N=<N>）
from pathlib import Path
import subprocess

BASE = Path(f"/content/result_N={WINDOW_N}")   # 前面互動輸入 N 時已建立
pos_in = BASE / "pos.fasta"
neg_in = BASE / "neg.fasta"
assert pos_in.exists() and neg_in.exists(), "找不到 pos/neg.fasta，先跑前處理！"

# identity 與對應 word size
idents = [("1.00",5), ("0.90",5), ("0.80",5), ("0.70",4), ("0.60",4), ("0.50",3)]

def run_cd_hit(in_fa: Path, prefix: str):
    for c, n in idents:
        out_fa = BASE / f"{prefix}_cd_hit{c}.fasta"
        cmd = [
            "cd-hit",
            "-i", str(in_fa),
            "-o", str(out_fa),
            "-c", c,
            "-n", str(n),
            "-d", "0",   # 保留完整標頭
            "-T", "0",   # 用盡可用 threads
        ]
        print("RUN:", " ".join(cmd))
        subprocess.run(cmd, check=True)

# 跑 Positive / Negative，都存回同一個 N 資料夾
run_cd_hit(pos_in, "pos")
run_cd_hit(neg_in, "neg")

print("完成，輸出位於：", BASE)

import pandas as pd

def count_clusters(p: Path):
    clstr = p.with_suffix(p.suffix + ".clstr")
    if not clstr.exists(): return None
    return sum(1 for line in open(clstr) if line.startswith(">Cluster"))

rows = []
for c,_ in idents:
    rows.append({
        "Sequence identity": f"{int(float(c)*100)}%",
        "Positive data (clusters)": count_clusters(BASE / f"pos_cd_hit{c}.fasta"),
        "Negative data (clusters)": count_clusters(BASE / f"neg_cd_hit{c}.fasta"),
    })
df = pd.DataFrame(rows)
df.to_csv(BASE / "cluster_counts_summary.csv", index=False)
df
